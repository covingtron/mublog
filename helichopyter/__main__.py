"""Helichopyter main entry point."""

import argparse
import importlib.util
import subprocess
import sys
from pathlib import Path
from typing import Any

from . import _Block, definitions


def _format_str(value: str) -> str:
    if value.startswith(('terraform.', 'var.', 'local.')):
        return value
    if '${' in value:
        return f'"{value}"'
    if '\n' in value:
        return f'<<-EOF\n{value}\nEOF'
    escaped = value.replace('\\', '\\\\').replace('"', '\\"')
    return f'"{escaped}"'


def _format_list(value: list[Any], indent: int) -> str:
    if not value:
        return '[]'
    items = [format_value(item, indent + 1) for item in value]
    pad = '  ' * indent
    inner_pad = '  ' * (indent + 1)
    return '[\n' + ',\n'.join(f'{inner_pad}{item}' for item in items) + ',\n' + pad + ']'


def _format_dict(value: dict[str, Any], indent: int) -> str:
    if not value:
        return '{}'
    lines = []
    for k, v in value.items():
        lines.append(f'{k} = {format_value(v, indent + 1)}')
    pad = '  ' * indent
    inner_pad = '  ' * (indent + 1)
    return '{\n' + '\n'.join(f'{inner_pad}{line}' for line in lines) + '\n' + pad + '}'


def format_value(value: Any, indent: int = 0) -> str:
    if isinstance(value, bool):
        return 'true' if value else 'false'
    if isinstance(value, str):
        return _format_str(value)
    if isinstance(value, list):
        return _format_list(value, indent)
    if isinstance(value, dict):
        return _format_dict(value, indent)
    if isinstance(value, _Block):
        pad = '  ' * indent
        lines = render_block_contents(value._contents, indent + 1)
        return f'{{\n{lines}\n{pad}}}'
    return str(value)


def render_block_contents(kwargs: dict[str, Any], indent: int = 1) -> str:
    pad = '  ' * indent
    lines = []
    for key, value in kwargs.items():
        if isinstance(value, _Block):
            block_lines = render_block_contents(value._contents, indent + 1)
            lines.append(f'{pad}{value._name} {{')
            lines.append(block_lines)
            lines.append(f'{pad}}}')
        elif isinstance(value, list) and value and isinstance(value[0], _Block):
            for block_item in value:
                block_lines = render_block_contents(block_item._contents, indent + 1)
                lines.append(f'{pad}{block_item._name} {{')
                lines.append(block_lines)
                lines.append(f'{pad}}}')
        elif isinstance(value, dict) and '_provisioner' in value:
            prov_type = value['_provisioner']
            prov_args = value['args']
            lines.append(f'{pad}provisioner "{prov_type}" {{')
            lines.append(render_block_contents(prov_args, indent + 1))
            lines.append(f'{pad}}}')
        else:
            lines.append(f'{pad}{key} = {format_value(value, indent)}')
    return '\n'.join(lines)


def _load_module(source_path: Path) -> None:
    definitions.clear()
    spec = importlib.util.spec_from_file_location('main_module', source_path)
    if spec and spec.loader:
        module = importlib.util.module_from_spec(spec)
        sys.modules['main_module'] = module
        spec.loader.exec_module(module)


class _HclGenerator:
    def __init__(self) -> None:
        self.terraform_config: dict[str, Any] = {}
        self.providers: list[tuple[str, dict[str, Any]]] = []
        self.locals_blocks: list[dict[str, Any]] = []
        self.resources: list[tuple[str, str, tuple[Any, ...], dict[str, Any]]] = []
        self.data_sources: list[tuple[str, str, dict[str, Any]]] = []
        self.variables: list[tuple[str, dict[str, Any]]] = []
        self.outputs: list[tuple[str, dict[str, Any]]] = []

    def process_definitions(self) -> None:
        for definition in definitions:
            type_ = definition[0]
            if type_ == 'terraform':
                subtype = definition[1]
                if subtype == 'required_providers':
                    self.terraform_config['required_providers'] = definition[2]
            elif type_ == 'provider':
                self.providers.append((definition[1], definition[2]))
            elif type_ == 'locals':
                self.locals_blocks.append(definition[1])
            elif type_ == 'resource':
                self.resources.append((definition[1], definition[2], definition[3], definition[4]))
            elif type_ == 'data':
                self.data_sources.append((definition[1], definition[2], definition[3]))
            elif type_ == 'variable':
                self.variables.append((definition[1], definition[2]))
            elif type_ == 'output':
                self.outputs.append((definition[1], definition[2]))

    def generate(self) -> str:
        output_lines = ['# AUTOGENERATED by helicopyter', '']

        if self.terraform_config:
            self._generate_terraform(output_lines)

        self._generate_named_blocks(output_lines, 'provider', self.providers)
        self._generate_locals(output_lines)
        self._generate_named_blocks(output_lines, 'variable', self.variables)
        self._generate_data_sources(output_lines)
        self._generate_resources(output_lines)
        self._generate_named_blocks(output_lines, 'output', self.outputs)

        return '\n'.join(output_lines)

    def _generate_terraform(self, output_lines: list[str]) -> None:
        output_lines.append('terraform {')
        if 'required_providers' in self.terraform_config:
            output_lines.append('  required_providers {')
            for prov_name, prov_config in self.terraform_config['required_providers'].items():
                output_lines.append(f'    {prov_name} = {{')
                for k, v in prov_config.items():
                    output_lines.append(f'      {k} = {format_value(v, 3)}')
                output_lines.append('    }')
            output_lines.append('  }')
        output_lines.append('}')
        output_lines.append('')

    def _generate_named_blocks(
        self, output_lines: list[str], block_type: str, items: list[tuple[str, dict[str, Any]]]
    ) -> None:
        for name, kwargs in items:
            output_lines.append(f'{block_type} "{name}" {{')
            if kwargs:
                output_lines.append(render_block_contents(kwargs, 1))
            output_lines.append('}')
            output_lines.append('')

    def _generate_locals(self, output_lines: list[str]) -> None:
        for local_kwargs in self.locals_blocks:
            output_lines.append('locals {')
            output_lines.append(render_block_contents(local_kwargs, 1))
            output_lines.append('}')
            output_lines.append('')

    def _generate_data_sources(self, output_lines: list[str]) -> None:
        for data_type, data_name, data_kwargs in self.data_sources:
            output_lines.append(f'data "{data_type}" "{data_name}" {{')
            if data_kwargs:
                output_lines.append(render_block_contents(data_kwargs, 1))
            output_lines.append('}')
            output_lines.append('')

    def _generate_resources(self, output_lines: list[str]) -> None:
        for res_type, res_name, res_args, res_kwargs in self.resources:
            output_lines.append(f'resource "{res_type}" "{res_name}" {{')
            if res_kwargs:
                output_lines.append(render_block_contents(res_kwargs, 1))
            for arg in res_args:
                if isinstance(arg, dict) and '_provisioner' in arg:
                    prov_type = arg['_provisioner']
                    prov_args = arg['args']
                    output_lines.append(f'  provisioner "{prov_type}" {{')
                    output_lines.append(render_block_contents(prov_args, 2))
                    output_lines.append('  }')
            output_lines.append('}')
            output_lines.append('')


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument('source', help='Path to the python source file')
    args = parser.parse_args()

    source_path = Path(args.source).resolve()

    _load_module(source_path)

    generator = _HclGenerator()
    generator.process_definitions()
    unformatted = generator.generate()

    output_file = source_path.parent / 'terraform' / 'main.tf'

    try:
        formatted = subprocess.run(
            ['tofu', 'fmt', '-'], input=unformatted, capture_output=True, text=True, check=True
        ).stdout
        output_file.write_text(formatted)
    except (subprocess.CalledProcessError, FileNotFoundError):
        output_file.write_text(unformatted)


if __name__ == '__main__':
    main()
